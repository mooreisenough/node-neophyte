{"version":3,"sources":["../es6/arrow-functions.js"],"names":[],"mappings":"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","file":"arrow-functions-babel.js","sourcesContent":["(() => {\n\t'use strict';\n\t\n\t// create wrapper arrow function expression of console.log\n\tvar log = message => console.log(message);\n\n\tlog('Testing out arrow functions!');\n\n\t// instead of specifying a traditional anonymous function \n\t// expression to map we can use an arrow function\n\tlog([1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(value => value * value));\n\n\t// arrow functions are function expressions and can be\n\t// assigned to variables\n\tvar descendingSortFunc = (a, b) => b - a,\n\t\tvalues = [2, 7, 5, 6],\n\t\tsortedValues = values.sort(descendingSortFunc);\n\n\tlog(values);\n\tlog(sortedValues);\n\n\t// SYNTAX GOTCHA: objects my be wrapped in parenthesis\n\n\t// returns an array of undefined values because the\n\t// {} is interpreted as an empty code block that returns\n\t// nothing\n\tlog([4, 6, 2].map(x => {}));\n\n\t// also returns an array of undefined values because the\n\t// {foo: x} is interpreted as a code block with the label\n\t// foo: that has an expression x that is NOT returned\n\tlog([4, 5, 1].map(x => {foo: x}));\n\n\t// successfully returns an array of empty objects\n\tlog([4, 5, 1].map(x => ({})));\n\n\t// successfully returns an object with \"foo\" as key\n\t// and number as value\n\tlog([4, 5, 1].map(x => ({foo: x})));\n\n\t// Immediately-invoked arrow functions work too!\n\t// Just be sure to put the parenthesis around the\n\t// arrow function expression and not around the whole thing\n\t(message => {\n\t\tfor (var charNo = 0; charNo < message.length; charNo++) {\n\t\t\tlog(message.charAt(charNo));\n\t\t}\n\t}) ('hello');\n\n\t// Arrow functions use lexical scoping for *this*, so it\n\t// can be referenced like you would expect within anonymous\n\t// functions\n\tvar car = {\n\t\tspeed: 0,\n\t\taccelerate: function() {\n\t\t\tthis.accelerator = setInterval(\n\t\t\t\t() => {\n\t\t\t\t\t// *this* is the same as it is outside\n\t\t\t\t\t// of the arrow function!\n\t\t\t\t\tthis.speed++;\n\t\t\t\t\tlog(this.speed);\n\t\t\t\t},\n\t\t\t\t100\n\t\t\t);\n\t\t},\n\t\tcruise: function() {\n\t\t\tclearInterval(this.accelerator);\n\t\t\tlog('cruising at ' + this.speed + ' mph');\n\t\t}\n\t};\n\n\tcar.accelerate();\n\n\tsetTimeout(\n\t\t() => car.cruise(),\n\t\t5000\n\t);\n\n\t// Arrow functions are identified as functions\n\tlog(typeof function() { }); // 'function'\n\tlog(typeof (() => {})); // 'function'\n\tlog(function() { } instanceof Function); // true\n\tlog((() => {}) instanceof Function); // true\n\n\n\tfunction generateArrowFunctionReturningLexicalArguments() {\n\t\t// returns an arrow function expression\n\t\t// which itself returns the arguments used\n\t\t// when generating the arrow function\n\t    return () => arguments;\n\t}\n\n\tvar arrowFunction = generateArrowFunctionReturningLexicalArguments(5, 'foo', [5,4,3]);\n\n\t// log arguments object with\n\t// 5, 'foo', and [5,4,3]\n\tlog(arrowFunction());\n}) ();\n"]}
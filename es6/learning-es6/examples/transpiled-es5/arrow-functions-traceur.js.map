{"version":3,"sources":["../es6/arrow-functions.js"],"names":[],"mappings":"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","file":"/Users/benmvp/github/benmvp/learning-es6/examples/transpiled-es5/arrow-functions-traceur.js","sourcesContent":["(() => {\n\t'use strict';\n\t\n\t// create wrapper arrow function expression of console.log\n\tvar log = message => console.log(message);\n\n\tlog('Testing out arrow functions!');\n\n\t// instead of specifying a traditional anonymous function \n\t// expression to map we can use an arrow function\n\tlog([1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(value => value * value));\n\n\t// arrow functions are function expressions and can be\n\t// assigned to variables\n\tvar descendingSortFunc = (a, b) => b - a,\n\t\tvalues = [2, 7, 5, 6],\n\t\tsortedValues = values.sort(descendingSortFunc);\n\n\tlog(values);\n\tlog(sortedValues);\n\n\t// SYNTAX GOTCHA: objects my be wrapped in parenthesis\n\n\t// returns an array of undefined values because the\n\t// {} is interpreted as an empty code block that returns\n\t// nothing\n\tlog([4, 6, 2].map(x => {}));\n\n\t// also returns an array of undefined values because the\n\t// {foo: x} is interpreted as a code block with the label\n\t// foo: that has an expression x that is NOT returned\n\tlog([4, 5, 1].map(x => {foo: x}));\n\n\t// successfully returns an array of empty objects\n\tlog([4, 5, 1].map(x => ({})));\n\n\t// successfully returns an object with \"foo\" as key\n\t// and number as value\n\tlog([4, 5, 1].map(x => ({foo: x})));\n\n\t// Immediately-invoked arrow functions work too!\n\t// Just be sure to put the parenthesis around the\n\t// arrow function expression and not around the whole thing\n\t(message => {\n\t\tfor (var charNo = 0; charNo < message.length; charNo++) {\n\t\t\tlog(message.charAt(charNo));\n\t\t}\n\t}) ('hello');\n\n\t// Arrow functions use lexical scoping for *this*, so it\n\t// can be referenced like you would expect within anonymous\n\t// functions\n\tvar car = {\n\t\tspeed: 0,\n\t\taccelerate: function() {\n\t\t\tthis.accelerator = setInterval(\n\t\t\t\t() => {\n\t\t\t\t\t// *this* is the same as it is outside\n\t\t\t\t\t// of the arrow function!\n\t\t\t\t\tthis.speed++;\n\t\t\t\t\tlog(this.speed);\n\t\t\t\t},\n\t\t\t\t100\n\t\t\t);\n\t\t},\n\t\tcruise: function() {\n\t\t\tclearInterval(this.accelerator);\n\t\t\tlog('cruising at ' + this.speed + ' mph');\n\t\t}\n\t};\n\n\tcar.accelerate();\n\n\tsetTimeout(\n\t\t() => car.cruise(),\n\t\t5000\n\t);\n\n\t// Arrow functions are identified as functions\n\tlog(typeof function() { }); // 'function'\n\tlog(typeof (() => {})); // 'function'\n\tlog(function() { } instanceof Function); // true\n\tlog((() => {}) instanceof Function); // true\n\n\n\tfunction generateArrowFunctionReturningLexicalArguments() {\n\t\t// returns an arrow function expression\n\t\t// which itself returns the arguments used\n\t\t// when generating the arrow function\n\t    return () => arguments;\n\t}\n\n\tvar arrowFunction = generateArrowFunctionReturningLexicalArguments(5, 'foo', [5,4,3]);\n\n\t// log arguments object with\n\t// 5, 'foo', and [5,4,3]\n\tlog(arrowFunction());\n}) ();\n"]}